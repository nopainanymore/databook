# Redis核心技术与实战

[toc]

## 01 | 基本架构：一个键值数据库包含什么？

更好的方式，是建立起“系统观”，如果我们想要深入理解一门技术，一个组件，就必须要对它的**总体架构**和**关键模块**有一个**全局**的认知，然后再**深入**到具体的技术点

Redis 支持的 value 类型包括了 String、哈希表、列表、集合等。Redis 能够在实际业务场景中得到广泛的应用，**就是得益于支持多样化类型的 value。**

**键值对保存在内存还是外存**

保存在内存的好处是读写很快，毕竟内存的访问速度一般都在百 ns 级别。但是，潜在的风险是一旦掉电，所有的数据都会丢失。保存在外存，虽然可以避免数据丢失，但是受限于磁盘的慢速读写（通常在几 ms 级别），键值数据库的整体性能会被拉低。

**如何进行设计选择，我们通常需要考虑键值数据库的主要应用场景**

![image](https://static.lovedata.net/20-11-17-c8029ae7151bdde4011ffceff8c557e3.png-wm)



**不同的 I/O 模型对键值数据库的性能和可扩展性会有不同的影响**  单线程，多线程，协同？

单线程处理网络解析，数据操作，某一步阻塞了，整个就阻塞了，影响流程，多线程的话，一个线程阻塞了，其他线程还可以继续工作，但是这就有一个共享资源的问题，如何处理线程竞争，线程切换，同样也会耗费资源

**索引的作用是让键值数据库根据 key 找到相应 value 的存储位置，进而执行操作。**

哈希表、B+ 树、字典树  Memcached 和 Redis 采用哈希表作为 key-value 索引，而 RocksDB 则采用跳表作为内存中 key-value 的索引

内存键值数据库（例如 Redis）采用哈希表作为索引，很大一部分原因在于，其键值数据基本都是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表 O(1) 的操作复杂度相匹配。



![image](https://static.lovedata.net/20-11-17-0c7bb79d52845ebf97647248651097c2.png-wm)



SimpleKV和Redis的对比：
【数据结构】上缺乏广泛的数据结构支持：比如支持范围查询的SkipList，和Stream等等数据结构
【高可用】上缺乏，哨兵或者master-slaver模式的高可用设计
【横向扩展】上缺乏集群和分片功能
【在内存安全性】上，缺乏内存过载时候的key淘汰算法的支持
【内存利用率】没有充分对数据结构优化提高内存利用率，例如使用压缩性的数据结构
【功能扩展】需要具备后续功能的拓展
【不具备事务性】无法保证多个操作的原子性

内存分配器，SimpleKV就是glibc，Redis的分配器选择更多

跳表是在Redis的value类型为有序集合时采用的一种数据组织结构，作为集合内元素的索引，在有序集合中进行操作时会依赖于跳表索引。但是从key找到value本身这个过程还是由全局哈希表索引完成。



## 02 | 数据结构：快速的Redis有哪些慢操作？



### Redis的快

它接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。



### 数据结构 

数据保存形式 ： String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）

底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。

![image](https://static.lovedata.net/20-11-17-2238178df0422bb718eec74748bdcead.png-wm)



键和值用什么结构组织？

Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据

**哈希桶中的元素保存的并不是值本身，而是指向具体值的指针**

![image](https://static.lovedata.net/20-11-17-9b64dce1390abb198f99608a939d2212.png-wm)



#### 哈希表的优点

我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。



### 为什么哈希表操作变慢了？

哈希表的冲突问题和 rehash 可能带来的操作阻塞

哈希冲突，也就是指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。

Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

![image](https://static.lovedata.net/20-11-17-d135b10ff6422d469795977fb0090827.png-wm)



#### 问题

哈希冲突链上的元素只能通过指针逐一查找再操作,数据越多，hash冲突越多，hash冲突链路过长，导致这个链上的查找速度变慢



#### ReHash

rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突

Redis使用两个全局hash表，哈希表1和哈希表2，最开始插入数据默认使用哈希表1，此时hash表2没有被分配空间，随着数据增多，redis开始进行rehash，三个步骤

1. 给hash表2分配更大的空间，more嗯hash表1的两倍
2. 把hash表1的数据重新映射到hash表2
3. 释放hash表1

#### 渐进式Rehash(防止进程暂定)

[渐进式 rehash — Redis 设计与实现](http://redisbook.com/preview/dict/incremental_rehashing.html)

Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的**第一个索引位置（这里redis内部维护了一个rehashidx，初始值是-1，后面每次操作会加1，rehash完之后就会重新置为-1）**开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。

![img](https://static001.geekbang.org/resource/image/73/0c/73fb212d0b0928d96a0d7d6ayy76da0c.jpg)



### 底层数据结构

#### 压缩列表

列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend

第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时 逐个查找，此时的复杂度就是 O(N) 了。

![image](https://static.lovedata.net/20-11-17-18eab57b473c1525e8607a57b101df17.png-wm)



#### 跳表

跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位

查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是 O(logN)。

![image](https://static.lovedata.net/20-11-17-035887690a0464ba4532cbc1f8eda582.png-wm)



![image](https://static.lovedata.net/20-11-17-bf77260f04425534a8d4616660e6028a.png-wm)

### 常见操作复杂度

单元素操作是基础；

范围操作非常耗时；

统计操作通常高效；

例外情况只有几个。



整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？

  1，数组和压缩列表可以提升内存利用率，因为他们的数据结构紧凑
  2，数组对CPU高速缓存支持友好，当数据元素超过阈值时，会转为hash和跳表，保证查询效率



## 03 | 高性能IO模型：为什么单线程Redis能那么快？

### 单线程？

Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。

但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。



### 为什么

#### 多线程的开销

通常理解： 使用多线程，可以增加系统吞吐率，或是可以增加系统扩展性

理想与现实

![image](https://static.lovedata.net/20-11-17-5cde7abb083fbfa667d341712d8a1332.png-wm)



系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构 ，保证正确性，就需要一个额外的机制，就带来了一些开销

**多线程编程模式面临的共享资源的并发访问控制问题**。

![img](https://static001.geekbang.org/resource/image/30/08/303255dcce6d0837bf7e2440df0f8e08.jpg)

**为了避免这些问题，Redis 直接采用了单线程模式。**



### 单线程 Redis 为什么那么快？

> Redis 却能使用单线程模型达到每秒数十万级别的处理能力

- 内存 ，高效的数据结构，例如哈希表和跳表，

- 多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率

### 基本 IO 模型与阻塞点



![image](https://static.lovedata.net/20-11-17-50de090a9b352efb5e90f4a61a333712.png-wm)



在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。



### 非阻塞模式

主要体现在三个关键的函数调用上

![image](https://static.lovedata.net/20-11-17-4f0b4635562266815d55dfe35e4f1f33.png-wm)



### 基于多路复用的高性能 I/O 模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制

在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。

内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。



![img](https://static001.geekbang.org/resource/image/00/ea/00ff790d4f6225aaeeebba34a71d8bea.jpg)



图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字

为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。

FD有请求到达的时候，触发相应的事件，事件放入到一个事件队列之中，

因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。



## 04 | AOF日志：宕机了，Redis如何避免数据丢失？



一旦服务器宕机，内存中的数据将全部丢失。

Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照。

### AOF

WAL 写前日志

AOF 写后日志

![img](https://static001.geekbang.org/resource/image/40/1f/407f2686083afc37351cfd9107319a1f.jpg)

redo log（重做日志），记录的是修改后的数据，

**而 AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。**

![image](https://static.lovedata.net/20-11-17-4dc6329de8737389352e5f5f2c781095.png-wm)

#### 为什么写后记录日志？

为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。

所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。

而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。



**另外： 不会阻塞当前的写操作。**









